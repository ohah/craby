---
source: crates/craby_codegen/src/generators/cxx_generator.rs
expression: result
---
./cpp/CxxCrabyTestModule.cpp
#include "CxxCrabyTestModule.hpp"
#include "cxx.h"
#include "bridging-generated.hpp"
#include <react/bridging/Bridging.h>

using namespace facebook;

namespace craby {
namespace testmodule {
namespace modules {

std::string CxxCrabyTestModule::dataPath = std::string();

CxxCrabyTestModule::CxxCrabyTestModule(
    std::shared_ptr<react::CallInvoker> jsInvoker)
    : TurboModule(CxxCrabyTestModule::kModuleName, jsInvoker) {
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::testmodule::signals::SignalManager::getInstance();
  manager.registerDelegate(id,
    [this](const std::string& name, void* signal) {
      this->emit(name, reinterpret_cast<bridging::CrabyTestSignal*>(signal));
    }
  );
  callInvoker_ = std::move(jsInvoker);
  module_ = std::shared_ptr<craby::testmodule::bridging::CrabyTest>(
    craby::testmodule::bridging::createCrabyTest(
      reinterpret_cast<uintptr_t>(this),
      rust::Str(dataPath.data(), dataPath.size())).into_raw(),
    [](craby::testmodule::bridging::CrabyTest *ptr) { rust::Box<craby::testmodule::bridging::CrabyTest>::from_raw(ptr); }
  );
  threadPool_ = std::make_shared<craby::testmodule::utils::ThreadPool>(10);
  methodMap_["arrayBufferMethod"] = MethodMetadata{1, &CxxCrabyTestModule::arrayBufferMethod};
  methodMap_["arrayMethod"] = MethodMetadata{1, &CxxCrabyTestModule::arrayMethod};
  methodMap_["booleanMethod"] = MethodMetadata{1, &CxxCrabyTestModule::booleanMethod};
  methodMap_["camelMethod"] = MethodMetadata{2, &CxxCrabyTestModule::camelMethod};
  methodMap_["enumMethod"] = MethodMetadata{2, &CxxCrabyTestModule::enumMethod};
  methodMap_["nullableMethod"] = MethodMetadata{1, &CxxCrabyTestModule::nullableMethod};
  methodMap_["numericMethod"] = MethodMetadata{1, &CxxCrabyTestModule::numericMethod};
  methodMap_["objectMethod"] = MethodMetadata{1, &CxxCrabyTestModule::objectMethod};
  methodMap_["PascalMethod"] = MethodMetadata{2, &CxxCrabyTestModule::pascalMethod};
  methodMap_["promiseMethod"] = MethodMetadata{1, &CxxCrabyTestModule::promiseMethod};
  methodMap_["snakeMethod"] = MethodMetadata{2, &CxxCrabyTestModule::snakeMethod};
  methodMap_["stringMethod"] = MethodMetadata{1, &CxxCrabyTestModule::stringMethod};
  methodMap_["onSignal"] = MethodMetadata{1, &CxxCrabyTestModule::onSignal};
}

CxxCrabyTestModule::~CxxCrabyTestModule() {
  invalidate();
}

void CxxCrabyTestModule::invalidate() {
  if (invalidated_.exchange(true)) {
    return;
  }

  invalidated_.store(true);
  listenersMap_.clear();

  // Unregister from signal manager
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::testmodule::signals::SignalManager::getInstance();
  manager.unregisterDelegate(id);

  // Shutdown thread pool
  threadPool_->shutdown();
}

void CxxCrabyTestModule::emit(std::string name, bridging::CrabyTestSignal* signal) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;
  {
    std::lock_guard<std::mutex> lock(listenersMutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (auto &[_, listener] : it->second) {
        listeners.push_back(listener);
      }
    }
  }

  // Prepare payload: extract from signal or use undefined
  auto payloadPtr = std::make_shared<facebook::jsi::Value>();
  
  if (signal == nullptr) {
    *payloadPtr = facebook::jsi::Value::undefined();
  } else {
    // Use shared_ptr to manage signal lifetime across async callbacks
    auto signalPtr = std::shared_ptr<bridging::CrabyTestSignal>(
      signal,
      [](bridging::CrabyTestSignal* ptr) {
        // Use Rust FFI function to drop signal memory
        if (ptr != nullptr) {
          craby::testmodule::bridging::drop_signal(ptr);
        }
      }
    );

    // Extract payload using FFI function and convert to jsi::Value
    // We'll need to capture signalPtr in the lambda
    for (auto& listener : listeners) {
      try {
        callInvoker_->invokeAsync([listener, signalPtr, name](jsi::Runtime &rt) {
          jsi::Value data = jsi::Value::undefined();

          listener->call(rt, data);
        });
      } catch (const std::exception& err) {
        // Noop
      }
    }
    return;
  }

  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener, payloadPtr](jsi::Runtime &rt) {
        try {
          listener->call(rt, *payloadPtr);
        } catch (const jsi::JSError &err) {
          throw err;
        } catch (const std::exception &err) {
          throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
        }
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

jsi::Value CxxCrabyTestModule::arrayBufferMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<rust::Vec<uint8_t>>(rt, args[0], callInvoker);
    auto ret = craby::testmodule::bridging::arrayBufferMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::arrayMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<rust::Vec<double>>(rt, args[0], callInvoker);
    auto ret = craby::testmodule::bridging::arrayMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::booleanMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<bool>(rt, args[0], callInvoker);
    auto ret = craby::testmodule::bridging::booleanMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::camelMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    auto arg1 = react::bridging::fromJs<double>(rt, args[1], callInvoker);
    auto ret = craby::testmodule::bridging::camelMethod(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::enumMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0 = react::bridging::fromJs<craby::testmodule::bridging::MyEnum>(rt, args[0], callInvoker);
    auto arg1 = react::bridging::fromJs<craby::testmodule::bridging::SwitchState>(rt, args[1], callInvoker);
    auto ret = craby::testmodule::bridging::enumMethod(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::nullableMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<craby::testmodule::bridging::NullableNumber>(rt, args[0], callInvoker);
    auto ret = craby::testmodule::bridging::nullableMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::numericMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    auto ret = craby::testmodule::bridging::numericMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::objectMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<craby::testmodule::bridging::TestObject>(rt, args[0], callInvoker);
    auto ret = craby::testmodule::bridging::objectMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::pascalMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    auto arg1 = react::bridging::fromJs<double>(rt, args[1], callInvoker);
    auto ret = craby::testmodule::bridging::pascalMethod(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::promiseMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    react::AsyncPromise<double> promise(rt, callInvoker);

    thisModule.threadPool_->enqueue([it_, promise, arg0]() mutable {
      try {
        auto ret = craby::testmodule::bridging::promiseMethod(*it_, arg0);
        promise.resolve(ret);
      } catch (const jsi::JSError &err) {
        promise.reject(err.getMessage());
      } catch (const std::exception &err) {
        promise.reject(craby::testmodule::utils::errorMessage(err));
      }
    });

    return react::bridging::toJs(rt, promise);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::snakeMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    auto arg1 = react::bridging::fromJs<double>(rt, args[1], callInvoker);
    auto ret = craby::testmodule::bridging::snakeMethod(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::stringMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::testmodule::bridging::stringMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::onSignal(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "onSignal";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::testmodule::utils::errorMessage(err));
  }
}

} // namespace modules
} // namespace testmodule
} // namespace craby

./cpp/CxxCrabyTestModule.hpp
#pragma once

#include "CrabyUtils.hpp"
#include "ffi.rs.h"
#include <ReactCommon/TurboModule.h>
#include <jsi/jsi.h>
#include <memory>

namespace craby {
namespace testmodule {
namespace modules {

class JSI_EXPORT CxxCrabyTestModule : public facebook::react::TurboModule {
public:
  static constexpr const char *kModuleName = "CrabyTest";
  static std::string dataPath;

  CxxCrabyTestModule(std::shared_ptr<facebook::react::CallInvoker> jsInvoker);
  ~CxxCrabyTestModule();

  void invalidate();
  void emit(std::string name, bridging::CrabyTestSignal* signal);

  static facebook::jsi::Value
  arrayBufferMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  arrayMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  booleanMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  camelMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  enumMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  nullableMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  numericMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  objectMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  pascalMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  promiseMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  snakeMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  stringMethod(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

  static facebook::jsi::Value
  onSignal(facebook::jsi::Runtime &rt,
      facebook::react::TurboModule &turboModule,
      const facebook::jsi::Value args[], size_t count);

protected:
  std::shared_ptr<facebook::react::CallInvoker> callInvoker_;
  std::shared_ptr<craby::testmodule::bridging::CrabyTest> module_;
  std::atomic<bool> invalidated_{false};
  std::atomic<size_t> nextListenerId_{0};
  std::mutex listenersMutex_;
  std::unordered_map<
    std::string,
    std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>>
    listenersMap_;
  std::shared_ptr<craby::testmodule::utils::ThreadPool> threadPool_;
};

} // namespace modules
} // namespace testmodule
} // namespace craby

./cpp/bridging-generated.hpp
#pragma once

#include "cxx.h"
#include "ffi.rs.h"
#include <react/bridging/Bridging.h>
#include <variant>

using namespace facebook;

namespace testmodule {

class RustVecBuffer : public jsi::MutableBuffer {
public:
  explicit RustVecBuffer(rust::Vec<uint8_t> vec)
    : vec_(std::move(vec)) {}

  ~RustVecBuffer() override = default;

  size_t size() const override {
    return vec_.size();
  }

  uint8_t* data() override {
    return const_cast<uint8_t*>(vec_.data());
  }

private:
  rust::Vec<uint8_t> vec_;
};

} // namespace testmodule

namespace facebook {
namespace react {

template <>
struct Bridging<std::monostate> {
  static std::monostate fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    return std::monostate{};
  }

  static jsi::Value toJs(jsi::Runtime& rt, const std::monostate& value) {
    return jsi::Value::undefined();
  }
};

template <>
struct Bridging<rust::Str> {
  static rust::Str fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto str = value.asString(rt).utf8(rt);
    return rust::Str(str.data(), str.size());
  }

  static jsi::Value toJs(jsi::Runtime& rt, const rust::Str& value) {
    return react::bridging::toJs(rt, std::string(value.data(), value.size()));
  }
};

template <>
struct Bridging<rust::String> {
  static rust::String fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto str = value.asString(rt).utf8(rt);
    return rust::String(str.data(), str.size());
  }

  static jsi::Value toJs(jsi::Runtime& rt, const rust::String& value) {
    return react::bridging::toJs(rt, std::string(value.data(), value.size()));
  }
};

template <>
struct Bridging<rust::Vec<uint8_t>> {
  static rust::Vec<uint8_t> fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto arrayBuffer = value.asObject(rt).getArrayBuffer(rt);
    uint8_t* data = arrayBuffer.data(rt);
    size_t size = arrayBuffer.size(rt);
    rust::Vec<uint8_t> vec;
    vec.reserve(size);

    std::memcpy(vec.data(), data, size);

    return vec;
  }

  static jsi::Value toJs(jsi::Runtime& rt, const rust::Vec<uint8_t>& vec) {
    auto buffer = std::make_shared<testmodule::RustVecBuffer>(std::move(vec));
    return jsi::ArrayBuffer(rt, buffer);
  }
};

template <typename T>
struct Bridging<rust::Vec<T>> {
  static rust::Vec<T> fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto arr = value.asObject(rt).asArray(rt);
    size_t len = arr.length(rt);
    rust::Vec<T> vec;
    vec.reserve(len);

    for (size_t i = 0; i < len; i++) {
      auto element = arr.getValueAtIndex(rt, i);
      vec.push_back(react::bridging::fromJs<T>(rt, element, callInvoker));
    }

    return vec;
  }

  static jsi::Array toJs(jsi::Runtime& rt, const rust::Vec<T>& vec) {
    auto arr = jsi::Array(rt, vec.size());

    for (size_t i = 0; i < vec.size(); i++) {
      auto jsElement = react::bridging::toJs(rt, vec[i]);
      arr.setValueAtIndex(rt, i, jsElement);
    }

    return arr;
  }
};

template <>
struct Bridging<craby::testmodule::bridging::MyEnum> {
  static craby::testmodule::bridging::MyEnum fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto raw = value.asString(rt).utf8(rt);
    if (raw == "foo") {
      return craby::testmodule::bridging::MyEnum::Foo;
    } else if (raw == "bar") {
      return craby::testmodule::bridging::MyEnum::Bar;
    } else if (raw == "baz") {
      return craby::testmodule::bridging::MyEnum::Baz;
    } else {
      throw jsi::JSError(rt, "Invalid enum value (MyEnum)");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::testmodule::bridging::MyEnum value) {
    switch (value) {
      case craby::testmodule::bridging::MyEnum::Foo:
        return react::bridging::toJs(rt, "foo");
      case craby::testmodule::bridging::MyEnum::Bar:
        return react::bridging::toJs(rt, "bar");
      case craby::testmodule::bridging::MyEnum::Baz:
        return react::bridging::toJs(rt, "baz");
      default:
        throw jsi::JSError(rt, "Invalid enum value (MyEnum)");
    }
  }
};

template <>
struct Bridging<craby::testmodule::bridging::SwitchState> {
  static craby::testmodule::bridging::SwitchState fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto raw = value.asNumber();
    if (raw == 0) {
      return craby::testmodule::bridging::SwitchState::Off;
    } else if (raw == 1) {
      return craby::testmodule::bridging::SwitchState::On;
    } else {
      throw jsi::JSError(rt, "Invalid enum value (SwitchState)");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::testmodule::bridging::SwitchState value) {
    switch (value) {
      case craby::testmodule::bridging::SwitchState::Off:
        return react::bridging::toJs(rt, 0);
      case craby::testmodule::bridging::SwitchState::On:
        return react::bridging::toJs(rt, 1);
      default:
        throw jsi::JSError(rt, "Invalid enum value (SwitchState)");
    }
  }
};

template <>
struct Bridging<craby::testmodule::bridging::NullableString> {
  static craby::testmodule::bridging::NullableString fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    if (value.isNull()) {
      return craby::testmodule::bridging::NullableString{true, rust::String()};
    }

    auto val = react::bridging::fromJs<rust::String>(rt, value, callInvoker);
    auto ret = craby::testmodule::bridging::NullableString{false, val};

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::testmodule::bridging::NullableString value) {
    if (value.null) {
      return jsi::Value::null();
    }

    return react::bridging::toJs(rt, value.val);
  }
};

template <>
struct Bridging<craby::testmodule::bridging::SubObject> {
  static craby::testmodule::bridging::SubObject fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$a = obj.getProperty(rt, "a");
    auto obj$b = obj.getProperty(rt, "b");
    auto obj$c = obj.getProperty(rt, "c");

    auto _obj$a = react::bridging::fromJs<craby::testmodule::bridging::NullableString>(rt, obj$a, callInvoker);
    auto _obj$b = react::bridging::fromJs<double>(rt, obj$b, callInvoker);
    auto _obj$c = react::bridging::fromJs<bool>(rt, obj$c, callInvoker);

    craby::testmodule::bridging::SubObject ret = {
      _obj$a,
      _obj$b,
      _obj$c
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::testmodule::bridging::SubObject value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$a = react::bridging::toJs(rt, value.a);
    auto _obj$b = react::bridging::toJs(rt, value.b);
    auto _obj$c = react::bridging::toJs(rt, value.c);

    obj.setProperty(rt, "a", _obj$a);
    obj.setProperty(rt, "b", _obj$b);
    obj.setProperty(rt, "c", _obj$c);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::testmodule::bridging::NullableSubObject> {
  static craby::testmodule::bridging::NullableSubObject fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    if (value.isNull()) {
      return craby::testmodule::bridging::NullableSubObject{true, craby::testmodule::bridging::SubObject{}};
    }

    auto val = react::bridging::fromJs<craby::testmodule::bridging::SubObject>(rt, value, callInvoker);
    auto ret = craby::testmodule::bridging::NullableSubObject{false, val};

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::testmodule::bridging::NullableSubObject value) {
    if (value.null) {
      return jsi::Value::null();
    }

    return react::bridging::toJs(rt, value.val);
  }
};

template <>
struct Bridging<craby::testmodule::bridging::TestObject> {
  static craby::testmodule::bridging::TestObject fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$foo = obj.getProperty(rt, "foo");
    auto obj$bar = obj.getProperty(rt, "bar");
    auto obj$baz = obj.getProperty(rt, "baz");
    auto obj$sub = obj.getProperty(rt, "sub");
    auto obj$camelCase = obj.getProperty(rt, "camelCase");
    auto obj$pascalCase = obj.getProperty(rt, "PascalCase");
    auto obj$snakeCase = obj.getProperty(rt, "snake_case");

    auto _obj$foo = react::bridging::fromJs<rust::String>(rt, obj$foo, callInvoker);
    auto _obj$bar = react::bridging::fromJs<double>(rt, obj$bar, callInvoker);
    auto _obj$baz = react::bridging::fromJs<bool>(rt, obj$baz, callInvoker);
    auto _obj$sub = react::bridging::fromJs<craby::testmodule::bridging::NullableSubObject>(rt, obj$sub, callInvoker);
    auto _obj$camelCase = react::bridging::fromJs<double>(rt, obj$camelCase, callInvoker);
    auto _obj$pascalCase = react::bridging::fromJs<double>(rt, obj$pascalCase, callInvoker);
    auto _obj$snakeCase = react::bridging::fromJs<double>(rt, obj$snakeCase, callInvoker);

    craby::testmodule::bridging::TestObject ret = {
      _obj$foo,
      _obj$bar,
      _obj$baz,
      _obj$sub,
      _obj$camelCase,
      _obj$pascalCase,
      _obj$snakeCase
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::testmodule::bridging::TestObject value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$foo = react::bridging::toJs(rt, value.foo);
    auto _obj$bar = react::bridging::toJs(rt, value.bar);
    auto _obj$baz = react::bridging::toJs(rt, value.baz);
    auto _obj$sub = react::bridging::toJs(rt, value.sub);
    auto _obj$camelCase = react::bridging::toJs(rt, value.camel_case);
    auto _obj$pascalCase = react::bridging::toJs(rt, value.pascal_case);
    auto _obj$snakeCase = react::bridging::toJs(rt, value.snake_case);

    obj.setProperty(rt, "foo", _obj$foo);
    obj.setProperty(rt, "bar", _obj$bar);
    obj.setProperty(rt, "baz", _obj$baz);
    obj.setProperty(rt, "sub", _obj$sub);
    obj.setProperty(rt, "camelCase", _obj$camelCase);
    obj.setProperty(rt, "PascalCase", _obj$pascalCase);
    obj.setProperty(rt, "snake_case", _obj$snakeCase);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::testmodule::bridging::NullableNumber> {
  static craby::testmodule::bridging::NullableNumber fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    if (value.isNull()) {
      return craby::testmodule::bridging::NullableNumber{true, 0.0};
    }

    auto val = react::bridging::fromJs<double>(rt, value, callInvoker);
    auto ret = craby::testmodule::bridging::NullableNumber{false, val};

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::testmodule::bridging::NullableNumber value) {
    if (value.null) {
      return jsi::Value::null();
    }

    return react::bridging::toJs(rt, value.val);
  }
};

} // namespace react
} // namespace facebook

./cpp/CrabyUtils.hpp
#pragma once

#include "cxx.h"
#include "ffi.rs.h"
#include <condition_variable>
#include <functional>
#include <mutex>
#include <queue>
#include <thread>
#include <vector>

namespace craby {
namespace testmodule {
namespace utils {

class ThreadPool {
private:
  bool stop;
  std::mutex mutex;
  std::condition_variable condition;
  std::queue<std::function<void()>> tasks;
  std::vector<std::thread> workers;

public:
  ThreadPool(size_t num_threads = 10) : stop(false) {
    for (size_t i = 0; i < num_threads; ++i) {
      workers.emplace_back([this] {
        while (true) {
          std::function<void()> task;

          {
            std::unique_lock<std::mutex> lock(this->mutex);
            this->condition.wait(
                lock, [this] { return this->stop || !this->tasks.empty(); });

            if (this->stop && this->tasks.empty()) {
              return;
            }

            task = std::move(this->tasks.front());
            this->tasks.pop();
          }

          task();
        }
      });
    }
  }

  template <class F> void enqueue(F &&f) {
    {
      std::unique_lock<std::mutex> lock(mutex);
      if (stop) {
        return;
      }
      tasks.emplace(std::forward<F>(f));
    }
    condition.notify_one();
  }

  void shutdown() {
    {
      std::unique_lock<std::mutex> lock(mutex);
      stop = true;
      std::queue<std::function<void()>> empty;
      std::swap(tasks, empty);
    }

    condition.notify_all();

    for (std::thread &worker : workers) {
      if (worker.joinable()) {
        worker.join();
      }
    }
  }

  ~ThreadPool() {
    shutdown();
  }
};

inline std::string errorMessage(const std::exception &err) {
  const auto* rs_err = dynamic_cast<const rust::Error*>(&err);
  return std::string(rs_err ? rs_err->what() : err.what());
}

} // namespace utils
} // namespace testmodule
} // namespace craby

./crates/lib/include/CrabySignals.h
#pragma once

#include "rust/cxx.h"
#include <functional>
#include <memory>
#include <mutex>
#include <unordered_map>

namespace craby {
namespace testmodule {
namespace bridging {
  struct CrabyTestSignal;
}
namespace modules {
  class CxxCrabyTest;
}
}
}

namespace craby {
namespace testmodule {
namespace signals {

using Delegate = std::function<void(const std::string& signalName, void* signal)>;

class SignalManager {
public:
  static SignalManager& getInstance() {
    static SignalManager instance;
    return instance;
  }

  void emit(uintptr_t id, rust::Str name, craby::testmodule::bridging::CrabyTestSignal* signal) const {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = delegates_.find(id);
    if (it != delegates_.end()) {
      it->second(std::string(name), reinterpret_cast<void*>(signal));
    }
  }

  void registerDelegate(uintptr_t id, Delegate delegate) const {
    std::lock_guard<std::mutex> lock(mutex_);
    delegates_.insert_or_assign(id, delegate);
  }

  void unregisterDelegate(uintptr_t id) const {
    std::lock_guard<std::mutex> lock(mutex_);
    delegates_.erase(id);
  }

private:
  SignalManager() = default;
  mutable std::unordered_map<uintptr_t, Delegate> delegates_;
  mutable std::mutex mutex_;
};

inline const SignalManager& getSignalManager() {
  return SignalManager::getInstance();
}

} // namespace signals
} // namespace testmodule
} // namespace craby
