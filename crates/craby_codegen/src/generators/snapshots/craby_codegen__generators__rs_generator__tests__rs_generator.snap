---
source: crates/craby_codegen/src/generators/rs_generator.rs
expression: result
---
./crates/lib/src/lib.rs
#[rustfmt::skip]
pub(crate) mod ffi;
pub(crate) mod generated;

pub(crate) mod craby_test_impl;

./crates/lib/src/ffi.rs
#[rustfmt::skip]
use craby::prelude::*;

use crate::craby_test_impl::*;
use crate::generated::*;

use bridging::*;

#[cxx::bridge(namespace = "craby::testmodule::bridging")]
pub mod bridging {
    #[derive(Clone)]
    struct NullableNumber {
        null: bool,
        val: f64,
    }

    #[derive(Clone)]
    struct NullableString {
        null: bool,
        val: String,
    }

    #[derive(Clone)]
    struct SubObject {
        a: NullableString,
        b: f64,
        c: bool,
    }

    #[derive(Clone)]
    struct TestObject {
        foo: String,
        bar: f64,
        baz: bool,
        sub: NullableSubObject,
        camel_case: f64,
        pascal_case: f64,
        snake_case: f64,
    }

    #[derive(Clone)]
    struct NullableSubObject {
        null: bool,
        val: SubObject,
    }

    enum MyEnum {
        Foo,
        Bar,
        Baz,
    }

    enum SwitchState {
        Off,
        On,
    }

    extern "Rust" {
        type CrabyTest;

        #[cxx_name = "createCrabyTest"]
        fn create_craby_test(id: usize, data_path: &str) -> Box<CrabyTest>;

        #[cxx_name = "arrayMethod"]
        fn craby_test_array_method(it_: &mut CrabyTest, arg: Vec<f64>) -> Result<Vec<f64>>;

        #[cxx_name = "booleanMethod"]
        fn craby_test_boolean_method(it_: &mut CrabyTest, arg: bool) -> Result<bool>;

        #[cxx_name = "camelMethod"]
        fn craby_test_camel_method(it_: &mut CrabyTest, first_arg: f64, second_arg: f64) -> Result<f64>;

        #[cxx_name = "enumMethod"]
        fn craby_test_enum_method(it_: &mut CrabyTest, arg_0: MyEnum, arg_1: SwitchState) -> Result<String>;

        #[cxx_name = "nullableMethod"]
        fn craby_test_nullable_method(it_: &mut CrabyTest, arg: NullableNumber) -> Result<NullableNumber>;

        #[cxx_name = "numericMethod"]
        fn craby_test_numeric_method(it_: &mut CrabyTest, arg: f64) -> Result<f64>;

        #[cxx_name = "objectMethod"]
        fn craby_test_object_method(it_: &mut CrabyTest, arg: TestObject) -> Result<TestObject>;

        #[cxx_name = "pascalMethod"]
        fn craby_test_pascal_method(it_: &mut CrabyTest, first_arg: f64, second_arg: f64) -> Result<f64>;

        #[cxx_name = "promiseMethod"]
        fn craby_test_promise_method(it_: &mut CrabyTest, arg: f64) -> Result<f64>;

        #[cxx_name = "snakeMethod"]
        fn craby_test_snake_method(it_: &mut CrabyTest, first_arg: f64, second_arg: f64) -> Result<f64>;

        #[cxx_name = "stringMethod"]
        fn craby_test_string_method(it_: &mut CrabyTest, arg: &str) -> Result<String>;
    }

    extern "Rust" {
        type CrabyTestSignal;
        unsafe fn drop_signal(signal: *mut CrabyTestSignal);
    }

    #[namespace = "craby::testmodule::signals"]
    unsafe extern "C++" {
        include!("CrabySignals.h");

        type SignalManager;

        unsafe fn emit(self: &SignalManager, id: usize, name: &str, signal: *mut CrabyTestSignal);
    
        #[rust_name = "get_signal_manager"]
        fn getSignalManager() -> &'static SignalManager;
    }
}

fn create_craby_test(id: usize, data_path: &str) -> Box<CrabyTest> {
    let ctx = Context::new(id, data_path);
    Box::new(CrabyTest::new(ctx))
}

fn craby_test_array_method(it_: &mut CrabyTest, arg: Vec<f64>) -> Result<Vec<f64>, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.array_method(arg);
        ret
    })
}

fn craby_test_boolean_method(it_: &mut CrabyTest, arg: bool) -> Result<bool, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.boolean_method(arg);
        ret
    })
}

fn craby_test_camel_method(it_: &mut CrabyTest, first_arg: f64, second_arg: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.camel_method(first_arg, second_arg);
        ret
    })
}

fn craby_test_enum_method(it_: &mut CrabyTest, arg_0: MyEnum, arg_1: SwitchState) -> Result<String, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.enum_method(arg_0, arg_1);
        ret
    })
}

fn craby_test_nullable_method(it_: &mut CrabyTest, arg: NullableNumber) -> Result<NullableNumber, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.nullable_method(arg.into());
        ret.into()
    })
}

fn craby_test_numeric_method(it_: &mut CrabyTest, arg: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.numeric_method(arg);
        ret
    })
}

fn craby_test_object_method(it_: &mut CrabyTest, arg: TestObject) -> Result<TestObject, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.object_method(arg);
        ret
    })
}

fn craby_test_pascal_method(it_: &mut CrabyTest, first_arg: f64, second_arg: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.pascal_method(first_arg, second_arg);
        ret
    })
}

fn craby_test_promise_method(it_: &mut CrabyTest, arg: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.promise_method(arg);
        ret
    }).and_then(|r| r)
}

fn craby_test_snake_method(it_: &mut CrabyTest, first_arg: f64, second_arg: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.snake_method(first_arg, second_arg);
        ret
    })
}

fn craby_test_string_method(it_: &mut CrabyTest, arg: &str) -> Result<String, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.string_method(arg);
        ret
    })
}

unsafe fn drop_signal(signal: *mut CrabyTestSignal) {
    if !signal.is_null() {
        let _ = Box::from_raw(signal);
    }
}

./crates/lib/src/generated.rs
// Hash: 01fedec5ee57afb3
#[rustfmt::skip]
use craby::prelude::*;

use crate::ffi::bridging::*;

pub trait CrabyTestSpec {
    fn new(ctx: Context) -> Self;
    fn id(&self) -> usize;
    fn emit(&self, signal_name: CrabyTestSignal) {
        let manager = crate::ffi::bridging::get_signal_manager();
        match signal_name {
            CrabyTestSignal::OnSignal => {
                unsafe {
                    let manager = crate::ffi::bridging::get_signal_manager();
                    manager.emit(self.id(), "onSignal", std::ptr::null_mut());
                }
            }
        }
    }
    fn array_method(&mut self, arg: Array<Number>) -> Array<Number>;
    fn boolean_method(&mut self, arg: Boolean) -> Boolean;
    fn camel_method(&mut self, first_arg: Number, second_arg: Number) -> Number;
    fn enum_method(&mut self, arg_0: MyEnum, arg_1: SwitchState) -> String;
    fn nullable_method(&mut self, arg: Nullable<Number>) -> Nullable<Number>;
    fn numeric_method(&mut self, arg: Number) -> Number;
    fn object_method(&mut self, arg: TestObject) -> TestObject;
    fn pascal_method(&mut self, first_arg: Number, second_arg: Number) -> Number;
    fn promise_method(&mut self, arg: Number) -> Promise<Number>;
    fn snake_method(&mut self, first_arg: Number, second_arg: Number) -> Number;
    fn string_method(&mut self, arg: &str) -> String;
}

pub enum CrabyTestSignal {
    OnSignal,
}

impl Default for SwitchState {
    fn default() -> Self {
        SwitchState::Off
    }
}

impl Default for NullableString {
    fn default() -> Self {
        NullableString {
            null: true,
            val: String::default(),
        }
    }
}

impl From<NullableString> for Nullable<String> {
    fn from(val: NullableString) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<String>> for NullableString {
    fn from(val: Nullable<String>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableString {
            val: val.unwrap_or(String::default()),
            null,
        }
    }
}

impl Default for TestObject {
    fn default() -> Self {
        TestObject {
            foo: String::default(),
            bar: 0.0,
            baz: false,
            sub: NullableSubObject::default(),
            camel_case: 0.0,
            pascal_case: 0.0,
            snake_case: 0.0
        }
    }
}

impl Default for MyEnum {
    fn default() -> Self {
        MyEnum::Foo
    }
}

impl Default for NullableNumber {
    fn default() -> Self {
        NullableNumber {
            null: true,
            val: 0.0,
        }
    }
}

impl From<NullableNumber> for Nullable<Number> {
    fn from(val: NullableNumber) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<Number>> for NullableNumber {
    fn from(val: Nullable<Number>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableNumber {
            val: val.unwrap_or(0.0),
            null,
        }
    }
}

impl Default for NullableSubObject {
    fn default() -> Self {
        NullableSubObject {
            null: true,
            val: SubObject::default(),
        }
    }
}

impl From<NullableSubObject> for Nullable<SubObject> {
    fn from(val: NullableSubObject) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<SubObject>> for NullableSubObject {
    fn from(val: Nullable<SubObject>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableSubObject {
            val: val.unwrap_or(SubObject::default()),
            null,
        }
    }
}

impl Default for SubObject {
    fn default() -> Self {
        SubObject {
            a: NullableString::default(),
            b: 0.0,
            c: false
        }
    }
}

./crates/lib/src/craby_test_impl.rs
use craby::{prelude::*, throw};

use crate::ffi::bridging::*;
use crate::generated::*;

pub struct CrabyTest {
    ctx: Context,
}

#[craby_module]
impl CrabyTestSpec for CrabyTest {
    fn array_method(&mut self, arg: Array<Number>) -> Array<Number> {
        unimplemented!();
    }

    fn boolean_method(&mut self, arg: Boolean) -> Boolean {
        unimplemented!();
    }

    fn camel_method(&mut self, first_arg: Number, second_arg: Number) -> Number {
        unimplemented!();
    }

    fn enum_method(&mut self, arg_0: MyEnum, arg_1: SwitchState) -> String {
        unimplemented!();
    }

    fn nullable_method(&mut self, arg: Nullable<Number>) -> Nullable<Number> {
        unimplemented!();
    }

    fn numeric_method(&mut self, arg: Number) -> Number {
        unimplemented!();
    }

    fn object_method(&mut self, arg: TestObject) -> TestObject {
        unimplemented!();
    }

    fn pascal_method(&mut self, first_arg: Number, second_arg: Number) -> Number {
        unimplemented!();
    }

    fn promise_method(&mut self, arg: Number) -> Promise<Number> {
        unimplemented!();
    }

    fn snake_method(&mut self, first_arg: Number, second_arg: Number) -> Number {
        unimplemented!();
    }

    fn string_method(&mut self, arg: &str) -> String {
        unimplemented!();
    }
}
