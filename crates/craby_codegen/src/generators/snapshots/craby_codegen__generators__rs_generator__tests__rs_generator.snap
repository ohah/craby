---
source: crates/craby_codegen/src/generators/rs_generator.rs
expression: "results.iter().map(|res|\nformat!(\"{}\\n{}\", res.path.display(),\nres.content)).collect::<Vec<_>>().join(\"\\n\\n\")"
---
./crates/lib/src/lib.rs
#[rustfmt::skip]
pub(crate) mod ffi;
pub(crate) mod generated;
pub(crate) mod types;

pub(crate) mod craby_test_impl;

./crates/lib/src/ffi.rs
#[rustfmt::skip]
use crate::craby_test_impl::*;
use crate::generated::*;

use bridging::*;

#[cxx::bridge(namespace = "craby::bridging")]
pub mod bridging {
    // Type definitions
    struct SubObject {
        a: String,
        b: f64,
        c: bool,
    }

    struct TestObject {
        foo: String,
        bar: f64,
        baz: bool,
        sub: SubObject,
    }

    enum MyEnum {
        FOO,
        BAR,
        BAZ,
    }

    extern "Rust" {
        #[cxx_name = "numericMethod"]
        fn craby_test_numeric_method(arg: f64) -> f64;

        #[cxx_name = "booleanMethod"]
        fn craby_test_boolean_method(arg: bool) -> bool;

        #[cxx_name = "stringMethod"]
        fn craby_test_string_method(arg: String) -> String;

        #[cxx_name = "objectMethod"]
        fn craby_test_object_method(arg: TestObject) -> TestObject;

        #[cxx_name = "arrayMethod"]
        fn craby_test_array_method(arg: Vec<f64>) -> Vec<f64>;

        #[cxx_name = "enumMethod"]
        fn craby_test_enum_method(arg: MyEnum) -> String;

        #[cxx_name = "promiseMethod"]
        fn craby_test_promise_method(arg: f64) -> Result<f64>;
    }
}

fn craby_test_numeric_method(arg: f64) -> f64 {
    let ret = CrabyTest::numeric_method(arg);
    ret
}

fn craby_test_boolean_method(arg: bool) -> bool {
    let ret = CrabyTest::boolean_method(arg);
    ret
}

fn craby_test_string_method(arg: String) -> String {
    let ret = CrabyTest::string_method(arg);
    ret
}

fn craby_test_object_method(arg: TestObject) -> TestObject {
    let ret = CrabyTest::object_method(arg);
    ret
}

fn craby_test_array_method(arg: Vec<f64>) -> Vec<f64> {
    let ret = CrabyTest::array_method(arg);
    ret
}

fn craby_test_enum_method(arg: MyEnum) -> String {
    let ret = CrabyTest::enum_method(arg);
    ret
}

fn craby_test_promise_method(arg: f64) -> Result<f64, anyhow::Error> {
    let ret = CrabyTest::promise_method(arg);
    ret
}

./crates/lib/src/generated.rs
#[rustfmt::skip]
use crate::ffi::bridging::*;
use crate::types::*;

pub trait CrabyTestSpec {
    fn numeric_method(arg: Number) -> Number;
    fn boolean_method(arg: Boolean) -> Boolean;
    fn string_method(arg: String) -> String;
    fn object_method(arg: TestObject) -> TestObject;
    fn array_method(arg: Array<Number>) -> Array<Number>;
    fn enum_method(arg: MyEnum) -> String;
    fn promise_method(arg: Number) -> Promise<Number>;
}

impl Default for MyEnum {
    fn default() -> Self {
        MyEnum::FOO
    }
}

impl Default for SubObject {
    fn default() -> Self {
        SubObject {
            a: String::default(),
            b: 0.0,
            c: false
        }
    }
}

impl Default for TestObject {
    fn default() -> Self {
        TestObject {
            foo: String::default(),
            bar: 0.0,
            baz: false,
            sub: SubObject::default()
        }
    }
}

./crates/lib/src/types.rs
#[rustfmt::skip]
pub type Boolean = bool;
pub type Number = f64;
pub type String = std::string::String;
pub type Array<T> = Vec<T>;
pub type Promise<T> = Result<T, anyhow::Error>;
pub type Void = ();

pub mod promise {
    use super::Promise;

    pub fn resolve<T>(val: T) -> Promise<T> {
        Ok(val)
    }

    pub fn rejected<T>(err: impl AsRef<str>) -> Promise<T> {
        Err(anyhow::anyhow!(err.as_ref().to_string()))
    }
}

pub struct Nullable<T> {
    val: Option<T>,
}

impl<T> Nullable<T> {
    pub fn new(val: Option<T>) -> Self {
        Nullable { val }
    }

    pub fn some(val: T) -> Self {
        Nullable { val: Some(val) }
    }

    pub fn none() -> Self {
        Nullable { val: None }
    }

    pub fn value(mut self, val: T) -> Self {
        self.val = Some(val);
        self
    }

    pub fn value_of(&self) -> Option<&T> {
        self.val.as_ref()
    }

    pub fn into_value(self) -> Option<T> {
        self.val
    }
}

./crates/lib/src/craby_test_impl.rs
use crate::{ffi::craby_test::*, generated::*};

pub struct CrabyTest;

impl CrabyTestSpec for CrabyTest {
    fn numeric_method(arg: Number) -> Number {
        unimplemented!();
    }

    fn boolean_method(arg: Boolean) -> Boolean {
        unimplemented!();
    }

    fn string_method(arg: String) -> String {
        unimplemented!();
    }

    fn object_method(arg: TestObject) -> TestObject {
        unimplemented!();
    }

    fn array_method(arg: Array<Number>) -> Array<Number> {
        unimplemented!();
    }

    fn enum_method(arg: MyEnum) -> String {
        unimplemented!();
    }

    fn promise_method(arg: Number) -> Promise<Number> {
        unimplemented!();
    }
}
