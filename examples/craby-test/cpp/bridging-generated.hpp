// Auto generated by Craby. DO NOT EDIT.
#pragma once

#include "cxx.h"
#include "ffi.rs.h"
#include <react/bridging/Bridging.h>
#include <variant>

using namespace facebook;

namespace crabytest {

class RustVecBuffer : public jsi::MutableBuffer {
public:
  explicit RustVecBuffer(rust::Vec<uint8_t> vec)
    : vec_(std::move(vec)) {}

  ~RustVecBuffer() override = default;

  size_t size() const override {
    return vec_.size();
  }

  uint8_t* data() override {
    return const_cast<uint8_t*>(vec_.data());
  }

private:
  rust::Vec<uint8_t> vec_;
};

} // namespace crabytest

namespace facebook {
namespace react {

template <>
struct Bridging<std::monostate> {
  static std::monostate fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    return std::monostate{};
  }

  static jsi::Value toJs(jsi::Runtime& rt, const std::monostate& value) {
    return jsi::Value::undefined();
  }
};

template <>
struct Bridging<rust::Str> {
  static rust::Str fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto str = value.asString(rt).utf8(rt);
    return rust::Str(str.data(), str.size());
  }

  static jsi::Value toJs(jsi::Runtime& rt, const rust::Str& value) {
    return react::bridging::toJs(rt, std::string(value.data(), value.size()));
  }
};

template <>
struct Bridging<rust::String> {
  static rust::String fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto str = value.asString(rt).utf8(rt);
    return rust::String(str.data(), str.size());
  }

  static jsi::Value toJs(jsi::Runtime& rt, const rust::String& value) {
    return react::bridging::toJs(rt, std::string(value.data(), value.size()));
  }
};

template <>
struct Bridging<rust::Vec<uint8_t>> {
  static rust::Vec<uint8_t> fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto arrayBuffer = value.asObject(rt).getArrayBuffer(rt);
    uint8_t* data = arrayBuffer.data(rt);
    size_t size = arrayBuffer.size(rt);
    rust::Vec<uint8_t> vec;
    vec.reserve(size);

    std::memcpy(vec.data(), data, size);

    return vec;
  }

  static jsi::Value toJs(jsi::Runtime& rt, const rust::Vec<uint8_t>& vec) {
    auto buffer = std::make_shared<crabytest::RustVecBuffer>(std::move(vec));
    return jsi::ArrayBuffer(rt, buffer);
  }
};

template <typename T>
struct Bridging<rust::Vec<T>> {
  static rust::Vec<T> fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto arr = value.asObject(rt).asArray(rt);
    size_t len = arr.length(rt);
    rust::Vec<T> vec;
    vec.reserve(len);

    for (size_t i = 0; i < len; i++) {
      auto element = arr.getValueAtIndex(rt, i);
      vec.push_back(react::bridging::fromJs<T>(rt, element, callInvoker));
    }

    return vec;
  }

  static jsi::Array toJs(jsi::Runtime& rt, const rust::Vec<T>& vec) {
    auto arr = jsi::Array(rt, vec.size());

    for (size_t i = 0; i < vec.size(); i++) {
      auto jsElement = react::bridging::toJs(rt, vec[i]);
      arr.setValueAtIndex(rt, i, jsElement);
    }

    return arr;
  }
};

template <>
struct Bridging<craby::crabytest::bridging::MyEnum> {
  static craby::crabytest::bridging::MyEnum fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto raw = value.asString(rt).utf8(rt);
    if (raw == "foo") {
      return craby::crabytest::bridging::MyEnum::Foo;
    } else if (raw == "bar") {
      return craby::crabytest::bridging::MyEnum::Bar;
    } else if (raw == "baz") {
      return craby::crabytest::bridging::MyEnum::Baz;
    } else {
      throw jsi::JSError(rt, "Invalid enum value (MyEnum)");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::crabytest::bridging::MyEnum value) {
    switch (value) {
      case craby::crabytest::bridging::MyEnum::Foo:
        return react::bridging::toJs(rt, "foo");
      case craby::crabytest::bridging::MyEnum::Bar:
        return react::bridging::toJs(rt, "bar");
      case craby::crabytest::bridging::MyEnum::Baz:
        return react::bridging::toJs(rt, "baz");
      default:
        throw jsi::JSError(rt, "Invalid enum value (MyEnum)");
    }
  }
};

template <>
struct Bridging<craby::crabytest::bridging::SwitchState> {
  static craby::crabytest::bridging::SwitchState fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto raw = value.asNumber();
    if (raw == 0) {
      return craby::crabytest::bridging::SwitchState::Off;
    } else if (raw == 1) {
      return craby::crabytest::bridging::SwitchState::On;
    } else {
      throw jsi::JSError(rt, "Invalid enum value (SwitchState)");
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::crabytest::bridging::SwitchState value) {
    switch (value) {
      case craby::crabytest::bridging::SwitchState::Off:
        return react::bridging::toJs(rt, 0);
      case craby::crabytest::bridging::SwitchState::On:
        return react::bridging::toJs(rt, 1);
      default:
        throw jsi::JSError(rt, "Invalid enum value (SwitchState)");
    }
  }
};

template <>
struct Bridging<craby::crabytest::bridging::MyModuleError> {
  static craby::crabytest::bridging::MyModuleError fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$reason = obj.getProperty(rt, "reason");

    auto _obj$reason = react::bridging::fromJs<rust::String>(rt, obj$reason, callInvoker);

    craby::crabytest::bridging::MyModuleError ret = {
      _obj$reason
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::crabytest::bridging::MyModuleError value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$reason = react::bridging::toJs(rt, value.reason);

    obj.setProperty(rt, "reason", _obj$reason);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::crabytest::bridging::NullableString> {
  static craby::crabytest::bridging::NullableString fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    if (value.isNull()) {
      return craby::crabytest::bridging::NullableString{true, rust::String()};
    }

    auto val = react::bridging::fromJs<rust::String>(rt, value, callInvoker);
    auto ret = craby::crabytest::bridging::NullableString{false, val};

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::crabytest::bridging::NullableString value) {
    if (value.null) {
      return jsi::Value::null();
    }

    return react::bridging::toJs(rt, value.val);
  }
};

template <>
struct Bridging<craby::crabytest::bridging::SubObject> {
  static craby::crabytest::bridging::SubObject fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$a = obj.getProperty(rt, "a");
    auto obj$b = obj.getProperty(rt, "b");
    auto obj$c = obj.getProperty(rt, "c");

    auto _obj$a = react::bridging::fromJs<craby::crabytest::bridging::NullableString>(rt, obj$a, callInvoker);
    auto _obj$b = react::bridging::fromJs<double>(rt, obj$b, callInvoker);
    auto _obj$c = react::bridging::fromJs<bool>(rt, obj$c, callInvoker);

    craby::crabytest::bridging::SubObject ret = {
      _obj$a,
      _obj$b,
      _obj$c
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::crabytest::bridging::SubObject value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$a = react::bridging::toJs(rt, value.a);
    auto _obj$b = react::bridging::toJs(rt, value.b);
    auto _obj$c = react::bridging::toJs(rt, value.c);

    obj.setProperty(rt, "a", _obj$a);
    obj.setProperty(rt, "b", _obj$b);
    obj.setProperty(rt, "c", _obj$c);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::crabytest::bridging::NullableSubObject> {
  static craby::crabytest::bridging::NullableSubObject fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    if (value.isNull()) {
      return craby::crabytest::bridging::NullableSubObject{true, craby::crabytest::bridging::SubObject{}};
    }

    auto val = react::bridging::fromJs<craby::crabytest::bridging::SubObject>(rt, value, callInvoker);
    auto ret = craby::crabytest::bridging::NullableSubObject{false, val};

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::crabytest::bridging::NullableSubObject value) {
    if (value.null) {
      return jsi::Value::null();
    }

    return react::bridging::toJs(rt, value.val);
  }
};

template <>
struct Bridging<craby::crabytest::bridging::ProgressEvent> {
  static craby::crabytest::bridging::ProgressEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$progress = obj.getProperty(rt, "progress");

    auto _obj$progress = react::bridging::fromJs<double>(rt, obj$progress, callInvoker);

    craby::crabytest::bridging::ProgressEvent ret = {
      _obj$progress
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::crabytest::bridging::ProgressEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$progress = react::bridging::toJs(rt, value.progress);

    obj.setProperty(rt, "progress", _obj$progress);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::crabytest::bridging::TestObject> {
  static craby::crabytest::bridging::TestObject fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$foo = obj.getProperty(rt, "foo");
    auto obj$bar = obj.getProperty(rt, "bar");
    auto obj$baz = obj.getProperty(rt, "baz");
    auto obj$sub = obj.getProperty(rt, "sub");
    auto obj$camelCase = obj.getProperty(rt, "camelCase");
    auto obj$pascalCase = obj.getProperty(rt, "PascalCase");
    auto obj$snakeCase = obj.getProperty(rt, "snake_case");

    auto _obj$foo = react::bridging::fromJs<rust::String>(rt, obj$foo, callInvoker);
    auto _obj$bar = react::bridging::fromJs<double>(rt, obj$bar, callInvoker);
    auto _obj$baz = react::bridging::fromJs<bool>(rt, obj$baz, callInvoker);
    auto _obj$sub = react::bridging::fromJs<craby::crabytest::bridging::NullableSubObject>(rt, obj$sub, callInvoker);
    auto _obj$camelCase = react::bridging::fromJs<double>(rt, obj$camelCase, callInvoker);
    auto _obj$pascalCase = react::bridging::fromJs<double>(rt, obj$pascalCase, callInvoker);
    auto _obj$snakeCase = react::bridging::fromJs<double>(rt, obj$snakeCase, callInvoker);

    craby::crabytest::bridging::TestObject ret = {
      _obj$foo,
      _obj$bar,
      _obj$baz,
      _obj$sub,
      _obj$camelCase,
      _obj$pascalCase,
      _obj$snakeCase
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::crabytest::bridging::TestObject value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$foo = react::bridging::toJs(rt, value.foo);
    auto _obj$bar = react::bridging::toJs(rt, value.bar);
    auto _obj$baz = react::bridging::toJs(rt, value.baz);
    auto _obj$sub = react::bridging::toJs(rt, value.sub);
    auto _obj$camelCase = react::bridging::toJs(rt, value.camel_case);
    auto _obj$pascalCase = react::bridging::toJs(rt, value.pascal_case);
    auto _obj$snakeCase = react::bridging::toJs(rt, value.snake_case);

    obj.setProperty(rt, "foo", _obj$foo);
    obj.setProperty(rt, "bar", _obj$bar);
    obj.setProperty(rt, "baz", _obj$baz);
    obj.setProperty(rt, "sub", _obj$sub);
    obj.setProperty(rt, "camelCase", _obj$camelCase);
    obj.setProperty(rt, "PascalCase", _obj$pascalCase);
    obj.setProperty(rt, "snake_case", _obj$snakeCase);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::crabytest::bridging::NullableNumber> {
  static craby::crabytest::bridging::NullableNumber fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    if (value.isNull()) {
      return craby::crabytest::bridging::NullableNumber{true, 0.0};
    }

    auto val = react::bridging::fromJs<double>(rt, value, callInvoker);
    auto ret = craby::crabytest::bridging::NullableNumber{false, val};

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::crabytest::bridging::NullableNumber value) {
    if (value.null) {
      return jsi::Value::null();
    }

    return react::bridging::toJs(rt, value.val);
  }
};

} // namespace react
} // namespace facebook
