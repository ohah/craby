// Auto generated by Craby. DO NOT EDIT.
#include "CxxCrabyTestModule.hpp"

#include <thread>
#include <react/bridging/Bridging.h>

#include "cxx.h"
#include "ffi.rs.h"
#include "bridging-generated.hpp"
#include "utils.hpp"

using namespace facebook;

namespace craby {
namespace crabytest {

CxxCrabyTestModule::CxxCrabyTestModule(
    std::shared_ptr<react::CallInvoker> jsInvoker)
    : TurboModule(CxxCrabyTestModule::kModuleName, jsInvoker) {
  callInvoker_ = std::move(jsInvoker);

  methodMap_["numericMethod"] = MethodMetadata{1, &CxxCrabyTestModule::numericMethod};
  methodMap_["booleanMethod"] = MethodMetadata{1, &CxxCrabyTestModule::booleanMethod};
  methodMap_["stringMethod"] = MethodMetadata{1, &CxxCrabyTestModule::stringMethod};
  methodMap_["objectMethod"] = MethodMetadata{1, &CxxCrabyTestModule::objectMethod};
  methodMap_["arrayMethod"] = MethodMetadata{1, &CxxCrabyTestModule::arrayMethod};
  methodMap_["enumMethod"] = MethodMetadata{1, &CxxCrabyTestModule::enumMethod};
  methodMap_["nullableMethod"] = MethodMetadata{1, &CxxCrabyTestModule::nullableMethod};
  methodMap_["promiseMethod"] = MethodMetadata{1, &CxxCrabyTestModule::promiseMethod};
}

jsi::Value CxxCrabyTestModule::numericMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    auto ret = craby::bridging::numericMethod(arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::booleanMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<bool>(rt, args[0], callInvoker);
    auto ret = craby::bridging::booleanMethod(arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::stringMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<rust::String>(rt, args[0], callInvoker);
    auto ret = craby::bridging::stringMethod(arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::objectMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<craby::bridging::TestObject>(rt, args[0], callInvoker);
    auto ret = craby::bridging::objectMethod(arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::arrayMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<rust::Vec<double>>(rt, args[0], callInvoker);
    auto ret = craby::bridging::arrayMethod(arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::enumMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<craby::bridging::MyEnum>(rt, args[0], callInvoker);
    auto ret = craby::bridging::enumMethod(arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::nullableMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<craby::bridging::NullableNumber>(rt, args[0], callInvoker);
    auto ret = craby::bridging::nullableMethod(arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::promiseMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    react::AsyncPromise<double> promise(rt, callInvoker);

    std::thread([promise, arg0]() mutable {
      try {
        auto ret = craby::bridging::promiseMethod(arg0);
        promise.resolve(ret);
      } catch (const jsi::JSError &err) {
        promise.reject(err.getMessage());
      } catch (const std::exception &err) {
        promise.reject(errorMessage(err));
      }
    }).detach();

    return react::bridging::toJs(rt, promise);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

} // namespace crabytest
} // namespace craby
