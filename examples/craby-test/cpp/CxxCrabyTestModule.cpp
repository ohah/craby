// Auto generated by Craby. DO NOT EDIT.
#include "CxxCrabyTestModule.hpp"
#include "cxx.h"
#include "bridging-generated.hpp"
#include <react/bridging/Bridging.h>

using namespace facebook;

namespace craby {
namespace crabytest {
namespace modules {

std::string CxxCrabyTestModule::dataPath = std::string();

CxxCrabyTestModule::CxxCrabyTestModule(
    std::shared_ptr<react::CallInvoker> jsInvoker)
    : TurboModule(CxxCrabyTestModule::kModuleName, jsInvoker) {
  callInvoker_ = std::move(jsInvoker);
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::crabytest::signals::SignalManager::getInstance();
  manager.registerDelegate(id,
                           [this](const std::string& name) {
                             this->emit(name);
                           });
  manager.registerDelegateWithValue(id,
                                    [this](const std::string& name, const facebook::jsi::Value& data) {
                                      this->emit(name, data);
                                    },
                                    [this](const std::string& name, rust::Vec<double> arr) {
                                      this->emitArrayNumber(name, arr);
                                    },
                                    [this](const std::string& name, rust::Vec<rust::String> arr) {
                                      this->emitArrayString(name, arr);
                                    },
                                    [this](const std::string& name, rust::Vec<rust::String> arr) {
                                      this->emitArrayObject(name, arr);
                                    },
                                    [this](const std::string& name, rust::Slice<const uint8_t> data) {
                                      this->emitObject(name, data);
                                    });
  module_ = std::shared_ptr<craby::crabytest::bridging::CrabyTest>(
    craby::crabytest::bridging::createCrabyTest(
      reinterpret_cast<uintptr_t>(this),
      rust::Str(dataPath.data(), dataPath.size())).into_raw(),
    [](craby::crabytest::bridging::CrabyTest *ptr) { rust::Box<craby::crabytest::bridging::CrabyTest>::from_raw(ptr); }
  );
  threadPool_ = std::make_shared<craby::crabytest::utils::ThreadPool>(10);
  methodMap_["arrayMethod"] = MethodMetadata{1, &CxxCrabyTestModule::arrayMethod};
  methodMap_["booleanMethod"] = MethodMetadata{1, &CxxCrabyTestModule::booleanMethod};
  methodMap_["camelMethod"] = MethodMetadata{0, &CxxCrabyTestModule::camelMethod};
  methodMap_["enumMethod"] = MethodMetadata{2, &CxxCrabyTestModule::enumMethod};
  methodMap_["getDataPath"] = MethodMetadata{0, &CxxCrabyTestModule::getDataPath};
  methodMap_["getState"] = MethodMetadata{0, &CxxCrabyTestModule::getState};
  methodMap_["nullableMethod"] = MethodMetadata{1, &CxxCrabyTestModule::nullableMethod};
  methodMap_["numericMethod"] = MethodMetadata{1, &CxxCrabyTestModule::numericMethod};
  methodMap_["objectMethod"] = MethodMetadata{1, &CxxCrabyTestModule::objectMethod};
  methodMap_["PascalMethod"] = MethodMetadata{0, &CxxCrabyTestModule::pascalMethod};
  methodMap_["promiseMethod"] = MethodMetadata{1, &CxxCrabyTestModule::promiseMethod};
  methodMap_["readData"] = MethodMetadata{0, &CxxCrabyTestModule::readData};
  methodMap_["setState"] = MethodMetadata{1, &CxxCrabyTestModule::setState};
  methodMap_["snake_method"] = MethodMetadata{0, &CxxCrabyTestModule::snakeMethod};
  methodMap_["stringMethod"] = MethodMetadata{1, &CxxCrabyTestModule::stringMethod};
  methodMap_["triggerSignal"] = MethodMetadata{0, &CxxCrabyTestModule::triggerSignal};
  methodMap_["triggerSignalArrayNumber"] = MethodMetadata{0, &CxxCrabyTestModule::triggerSignalArrayNumber};
  methodMap_["triggerSignalArrayObject"] = MethodMetadata{0, &CxxCrabyTestModule::triggerSignalArrayObject};
  methodMap_["triggerSignalArrayString"] = MethodMetadata{0, &CxxCrabyTestModule::triggerSignalArrayString};
  methodMap_["triggerSignalObject"] = MethodMetadata{0, &CxxCrabyTestModule::triggerSignalObject};
  methodMap_["writeData"] = MethodMetadata{1, &CxxCrabyTestModule::writeData};
  methodMap_["onFinished"] = MethodMetadata{1, &CxxCrabyTestModule::onFinished};
  methodMap_["onSignal"] = MethodMetadata{1, &CxxCrabyTestModule::onSignal};
}

CxxCrabyTestModule::~CxxCrabyTestModule() {
  invalidate();
}

void CxxCrabyTestModule::invalidate() {
  if (invalidated_.exchange(true)) {
    return;
  }

  invalidated_.store(true);
  listenersMap_.clear();

  // Unregister from signal manager
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::crabytest::signals::SignalManager::getInstance();
  manager.unregisterDelegate(id);

  // Shutdown thread pool
  threadPool_->shutdown();
}

void CxxCrabyTestModule::emit(std::string name) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;
  {
    std::lock_guard<std::mutex> lock(listenersMutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (auto &[_, listener] : it->second) {
        listeners.push_back(listener);
      }
    }
  }

  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener](jsi::Runtime &rt) {
        listener->call(rt);
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

void CxxCrabyTestModule::emit(std::string name, const facebook::jsi::Value& data) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;
  {
    std::lock_guard<std::mutex> lock(listenersMutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (auto &[_, listener] : it->second) {
        listeners.push_back(listener);
      }
    }
  }

  // jsi::Value는 Runtime에 종속적이므로, 현재 Runtime에서 직접 사용
  // data는 이미 현재 Runtime의 값이므로, 람다에서 직접 사용 가능
  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener, &data](jsi::Runtime &rt) {
        if (data.isUndefined()) {
          // 데이터 없음 - 기존 동작
          listener->call(rt);
        } else {
          // data를 현재 Runtime에서 직접 사용
          // jsi::Value는 Runtime에 종속적이지만, 같은 Runtime에서 사용 가능
          listener->call(rt, data);
        }
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

// Array<number> 타입 emit - SignalManager에서 호출
void CxxCrabyTestModule::emitArrayNumber(std::string name, const rust::Vec<double>& arr) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;
  {
    std::lock_guard<std::mutex> lock(listenersMutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (auto &[_, listener] : it->second) {
        listeners.push_back(listener);
      }
    }
  }

  // arr를 복사하여 람다에서 사용 (모든 리스너가 같은 복사본 공유)
  rust::Vec<double> arrCopy = arr;
  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener, arrCopy](jsi::Runtime &rt) {
        // Bridging<rust::Vec<double>>::toJs를 사용하여 rust::Vec를 jsi::Array로 변환
        auto jsArray = facebook::react::Bridging<rust::Vec<double>>::toJs(rt, arrCopy);
        // jsi::Array를 jsi::Value로 직접 변환 (jsi::Value는 jsi::Object를 받는 생성자가 있음)
        jsi::Value dataValue(std::move(jsArray));
        listener->call(rt, dataValue);
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

// Array<string> 타입 emit - SignalManager에서 호출
void CxxCrabyTestModule::emitArrayString(std::string name, const rust::Vec<rust::String>& arr) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;
  {
    std::lock_guard<std::mutex> lock(listenersMutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (auto &[_, listener] : it->second) {
        listeners.push_back(listener);
      }
    }
  }

  // arr를 복사하여 람다에서 사용 (모든 리스너가 같은 복사본 공유)
  rust::Vec<rust::String> arrCopy = arr;
  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener, arrCopy](jsi::Runtime &rt) {
        // Bridging<rust::Vec<rust::String>>::toJs를 사용하여 rust::Vec를 jsi::Array로 변환
        auto jsArray = facebook::react::Bridging<rust::Vec<rust::String>>::toJs(rt, arrCopy);
        // jsi::Array를 jsi::Value로 직접 변환 (jsi::Value는 jsi::Object를 받는 생성자가 있음)
        jsi::Value dataValue(std::move(jsArray));
        listener->call(rt, dataValue);
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

// Array<Object> 타입 emit - Rust에서 Vec<String>으로 전달받아 각 문자열을 JSON.parse하여 배열로 변환
void CxxCrabyTestModule::emitArrayObject(std::string name, const rust::Vec<rust::String>& arr) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;
  {
    std::lock_guard<std::mutex> lock(listenersMutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (auto &[_, listener] : it->second) {
        listeners.push_back(listener);
      }
    }
  }

  // arr를 복사하여 람다에서 사용 (모든 리스너가 같은 복사본 공유)
  rust::Vec<rust::String> arrCopy = arr;
  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener, arrCopy](jsi::Runtime &rt) {
        // JSON 객체 가져오기
        auto json = rt.global().getPropertyAsObject(rt, "JSON");
        auto jsonParse = json.getPropertyAsFunction(rt, "parse");
        
        // 각 JSON 문자열을 파싱하여 배열로 만들기
        auto jsArray = jsi::Array(rt, arrCopy.size());
        for (size_t i = 0; i < arrCopy.size(); ++i) {
          std::string jsonStr(arrCopy[i].data(), arrCopy[i].size());
          jsi::Value jsonStrValue = react::bridging::toJs(rt, jsonStr);
          auto jsonValue = jsonParse.call(rt, jsonStrValue.asString(rt));
          jsArray.setValueAtIndex(rt, i, jsonValue);
        }
        
        jsi::Value dataValue(std::move(jsArray));
        listener->call(rt, dataValue);
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

// Object 타입 emit - Rust에서 &[u8]로 전달받아 JSON으로 파싱하여 Object로 변환
void CxxCrabyTestModule::emitObject(std::string name, rust::Slice<const uint8_t> data) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;
  {
    std::lock_guard<std::mutex> lock(listenersMutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (auto &[_, listener] : it->second) {
        listeners.push_back(listener);
      }
    }
  }

  // data를 복사하여 람다에서 사용
  std::vector<uint8_t> dataCopy(data.begin(), data.end());
  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener, dataCopy](jsi::Runtime &rt) {
        // JSON 바이트를 문자열로 변환
        std::string jsonStr(dataCopy.begin(), dataCopy.end());
        // JSON 문자열을 jsi::Value로 파싱
        auto json = rt.global().getPropertyAsObject(rt, "JSON");
        auto jsonParse = json.getPropertyAsFunction(rt, "parse");
        jsi::Value jsonStrValue = react::bridging::toJs(rt, jsonStr);
        auto jsonValue = jsonParse.call(rt, jsonStrValue.asString(rt));
        listener->call(rt, jsonValue);
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

jsi::Value CxxCrabyTestModule::arrayMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<rust::Vec<double>>(rt, args[0], callInvoker);
    auto ret = craby::crabytest::bridging::arrayMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::booleanMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<bool>(rt, args[0], callInvoker);
    auto ret = craby::crabytest::bridging::booleanMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::camelMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::crabytest::bridging::camelMethod(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::enumMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0 = react::bridging::fromJs<craby::crabytest::bridging::MyEnum>(rt, args[0], callInvoker);
    auto arg1 = react::bridging::fromJs<craby::crabytest::bridging::SwitchState>(rt, args[1], callInvoker);
    auto ret = craby::crabytest::bridging::enumMethod(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::getDataPath(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::crabytest::bridging::getDataPath(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::getState(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::crabytest::bridging::getState(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::nullableMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<craby::crabytest::bridging::NullableNumber>(rt, args[0], callInvoker);
    auto ret = craby::crabytest::bridging::nullableMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::numericMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    auto ret = craby::crabytest::bridging::numericMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::objectMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<craby::crabytest::bridging::TestObject>(rt, args[0], callInvoker);
    auto ret = craby::crabytest::bridging::objectMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::pascalMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::crabytest::bridging::pascalMethod(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::promiseMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    react::AsyncPromise<double> promise(rt, callInvoker);

    thisModule.threadPool_->enqueue([it_, promise, arg0]() mutable {
      try {
        auto ret = craby::crabytest::bridging::promiseMethod(*it_, arg0);
        promise.resolve(ret);
      } catch (const jsi::JSError &err) {
        promise.reject(err.getMessage());
      } catch (const std::exception &err) {
        promise.reject(craby::crabytest::utils::errorMessage(err));
      }
    });

    return react::bridging::toJs(rt, promise);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::readData(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::crabytest::bridging::readData(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::setState(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    craby::crabytest::bridging::setState(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::snakeMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::crabytest::bridging::snakeMethod(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::stringMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::crabytest::bridging::stringMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::triggerSignal(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::crabytest::bridging::triggerSignal(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::triggerSignalArrayNumber(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::crabytest::bridging::triggerSignalArrayNumber(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::triggerSignalArrayObject(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::crabytest::bridging::triggerSignalArrayObject(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::triggerSignalArrayString(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::crabytest::bridging::triggerSignalArrayString(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::triggerSignalObject(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::crabytest::bridging::triggerSignalObject(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::writeData(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::crabytest::bridging::writeData(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::onFinished(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "onFinished";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::onSignal(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "onSignal";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::crabytest::utils::errorMessage(err));
  }
}

} // namespace modules
} // namespace crabytest
} // namespace craby
