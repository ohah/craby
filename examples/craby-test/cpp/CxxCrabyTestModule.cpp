// Auto generated by Craby. DO NOT EDIT.
#include "CxxCrabyTestModule.hpp"

#include "cxx.h"
#include "bridging-generated.hpp"
#include "utils.hpp"

#include <thread>
#include <react/bridging/Bridging.h>

using namespace facebook;

namespace craby {
namespace crabytest {

CxxCrabyTestModule::CxxCrabyTestModule(
    std::shared_ptr<react::CallInvoker> jsInvoker)
    : TurboModule(CxxCrabyTestModule::kModuleName, jsInvoker) {
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::signals::SignalManager::getInstance();
  manager.registerDelegate(id,
                           std::bind(&CxxCrabyTestModule::emit,
                           this,
                           std::placeholders::_1));
  callInvoker_ = std::move(jsInvoker);
  module_ = std::shared_ptr<craby::bridging::CrabyTest>(
    craby::bridging::createCrabyTest(reinterpret_cast<uintptr_t>(this)).into_raw(),
    [](craby::bridging::CrabyTest *ptr) { rust::Box<craby::bridging::CrabyTest>::from_raw(ptr); }
  );

  methodMap_["numericMethod"] = MethodMetadata{1, &CxxCrabyTestModule::numericMethod};
  methodMap_["booleanMethod"] = MethodMetadata{1, &CxxCrabyTestModule::booleanMethod};
  methodMap_["stringMethod"] = MethodMetadata{1, &CxxCrabyTestModule::stringMethod};
  methodMap_["objectMethod"] = MethodMetadata{1, &CxxCrabyTestModule::objectMethod};
  methodMap_["arrayMethod"] = MethodMetadata{1, &CxxCrabyTestModule::arrayMethod};
  methodMap_["enumMethod"] = MethodMetadata{2, &CxxCrabyTestModule::enumMethod};
  methodMap_["nullableMethod"] = MethodMetadata{1, &CxxCrabyTestModule::nullableMethod};
  methodMap_["promiseMethod"] = MethodMetadata{1, &CxxCrabyTestModule::promiseMethod};
  methodMap_["setState"] = MethodMetadata{1, &CxxCrabyTestModule::setState};
  methodMap_["getState"] = MethodMetadata{0, &CxxCrabyTestModule::getState};
  methodMap_["camelMethod"] = MethodMetadata{0, &CxxCrabyTestModule::camelMethod};
  methodMap_["PascalMethod"] = MethodMetadata{0, &CxxCrabyTestModule::pascalMethod};
  methodMap_["snake_method"] = MethodMetadata{0, &CxxCrabyTestModule::snakeMethod};
  methodMap_["triggerSignal"] = MethodMetadata{0, &CxxCrabyTestModule::triggerSignal};
  methodMap_["onSignal"] = MethodMetadata{1, &CxxCrabyTestModule::onSignal};
}

CxxCrabyTestModule::~CxxCrabyTestModule() {
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::signals::SignalManager::getInstance();
  manager.unregisterDelegate(id);
}

void CxxCrabyTestModule::emit(std::string name) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;

  {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (const auto& fn : it->second) {
        listeners.push_back(fn);
      }
    }
  }

  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener](jsi::Runtime &rt) {
        listener->call(rt);
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

jsi::Value CxxCrabyTestModule::numericMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    auto ret = craby::bridging::numericMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::booleanMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<bool>(rt, args[0], callInvoker);
    auto ret = craby::bridging::booleanMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::stringMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<rust::String>(rt, args[0], callInvoker);
    auto ret = craby::bridging::stringMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::objectMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<craby::bridging::TestObject>(rt, args[0], callInvoker);
    auto ret = craby::bridging::objectMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::arrayMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<rust::Vec<double>>(rt, args[0], callInvoker);
    auto ret = craby::bridging::arrayMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::enumMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0 = react::bridging::fromJs<craby::bridging::MyEnum>(rt, args[0], callInvoker);
    auto arg1 = react::bridging::fromJs<craby::bridging::SwitchState>(rt, args[1], callInvoker);
    auto ret = craby::bridging::enumMethod(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::nullableMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<craby::bridging::NullableNumber>(rt, args[0], callInvoker);
    auto ret = craby::bridging::nullableMethod(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::promiseMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    react::AsyncPromise<double> promise(rt, callInvoker);

    std::thread([it_, promise, arg0]() mutable {
      try {
        auto ret = craby::bridging::promiseMethod(*it_, arg0);
        promise.resolve(ret);
      } catch (const jsi::JSError &err) {
        promise.reject(err.getMessage());
      } catch (const std::exception &err) {
        promise.reject(errorMessage(err));
      }
    }).detach();

    return react::bridging::toJs(rt, promise);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::setState(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    craby::bridging::setState(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::getState(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }


    auto ret = craby::bridging::getState(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::camelMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }


    craby::bridging::camelMethod(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::pascalMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }


    craby::bridging::pascalMethod(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::snakeMethod(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }


    craby::bridging::snakeMethod(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::triggerSignal(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }


    craby::bridging::triggerSignal(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

jsi::Value CxxCrabyTestModule::onSignal(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxCrabyTestModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    uint64_t listenerId = nextListenerId_++;
    
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto name = "onSignal";
    
    if (listenersMap_.find(name) == listenersMap_.end()) {
      listenersMap_[name] = std::vector<std::shared_ptr<jsi::Function>>();
    }
    listenersMap_[name].push_back(callbackRef);

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [listenerId, callbackRef, name](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        std::lock_guard<std::mutex> lock(mutex_);
        auto& listeners = listenersMap_[name];
        listeners.erase(
          std::remove_if(listeners.begin(), listeners.end(),
          [&callbackRef](const std::shared_ptr<jsi::Function>& fn) {
            return fn.get() == callbackRef.get();
          }),
          listeners.end()
        );

        if (listeners.empty()) {
          listenersMap_.erase(name);
        }

        return jsi::Value::undefined();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, errorMessage(err));
  }
}

} // namespace crabytest
} // namespace craby
