// Auto generated by Craby. DO NOT EDIT.
#[rustfmt::skip]
use craby::prelude::*;

use crate::calculator_impl::*;
use crate::craby_test_impl::*;
use crate::generated::*;

use bridging::*;

#[cxx::bridge(namespace = "craby::crabytest::bridging")]
pub mod bridging {
    #[derive(Clone)]
    struct NullableNumber {
        null: bool,
        val: f64,
    }

    #[derive(Clone)]
    struct NullableString {
        null: bool,
        val: String,
    }

    #[derive(Clone)]
    struct SubObject {
        a: NullableString,
        b: f64,
        c: bool,
    }

    #[derive(Clone)]
    struct MyModuleError {
        reason: String,
    }

    #[derive(Clone)]
    struct TestObject {
        foo: String,
        bar: f64,
        baz: bool,
        sub: NullableSubObject,
        camel_case: f64,
        pascal_case: f64,
        snake_case: f64,
    }

    #[derive(Clone)]
    struct ProgressEvent {
        progress: f64,
    }

    #[derive(Clone)]
    struct NullableSubObject {
        null: bool,
        val: SubObject,
    }

    enum MyEnum {
        Foo,
        Bar,
        Baz,
    }

    enum SwitchState {
        Off,
        On,
    }

    extern "Rust" {
        type Calculator;

        type CrabyTest;

        #[cxx_name = "createCalculator"]
        fn create_calculator(id: usize, data_path: &str) -> Box<Calculator>;

        #[cxx_name = "add"]
        fn calculator_add(it_: &mut Calculator, a: f64, b: f64) -> Result<f64>;

        #[cxx_name = "divide"]
        fn calculator_divide(it_: &mut Calculator, a: f64, b: f64) -> Result<f64>;

        #[cxx_name = "multiply"]
        fn calculator_multiply(it_: &mut Calculator, a: f64, b: f64) -> Result<f64>;

        #[cxx_name = "subtract"]
        fn calculator_subtract(it_: &mut Calculator, a: f64, b: f64) -> Result<f64>;

        #[cxx_name = "createCrabyTest"]
        fn create_craby_test(id: usize, data_path: &str) -> Box<CrabyTest>;

        #[cxx_name = "arrayMethod"]
        fn craby_test_array_method(it_: &mut CrabyTest, arg: Vec<f64>) -> Result<Vec<f64>>;

        #[cxx_name = "booleanMethod"]
        fn craby_test_boolean_method(it_: &mut CrabyTest, arg: bool) -> Result<bool>;

        #[cxx_name = "camelMethod"]
        fn craby_test_camel_method(it_: &mut CrabyTest) -> Result<()>;

        #[cxx_name = "enumMethod"]
        fn craby_test_enum_method(it_: &mut CrabyTest, arg_0: MyEnum, arg_1: SwitchState) -> Result<String>;

        #[cxx_name = "getDataPath"]
        fn craby_test_get_data_path(it_: &mut CrabyTest) -> Result<String>;

        #[cxx_name = "getState"]
        fn craby_test_get_state(it_: &mut CrabyTest) -> Result<f64>;

        #[cxx_name = "nullableMethod"]
        fn craby_test_nullable_method(it_: &mut CrabyTest, arg: NullableNumber) -> Result<NullableNumber>;

        #[cxx_name = "numericMethod"]
        fn craby_test_numeric_method(it_: &mut CrabyTest, arg: f64) -> Result<f64>;

        #[cxx_name = "objectMethod"]
        fn craby_test_object_method(it_: &mut CrabyTest, arg: TestObject) -> Result<TestObject>;

        #[cxx_name = "pascalMethod"]
        fn craby_test_pascal_method(it_: &mut CrabyTest) -> Result<()>;

        #[cxx_name = "promiseMethod"]
        fn craby_test_promise_method(it_: &mut CrabyTest, arg: f64) -> Result<f64>;

        #[cxx_name = "readData"]
        fn craby_test_read_data(it_: &mut CrabyTest) -> Result<NullableString>;

        #[cxx_name = "setState"]
        fn craby_test_set_state(it_: &mut CrabyTest, arg: f64) -> Result<()>;

        #[cxx_name = "snakeMethod"]
        fn craby_test_snake_method(it_: &mut CrabyTest) -> Result<()>;

        #[cxx_name = "stringMethod"]
        fn craby_test_string_method(it_: &mut CrabyTest, arg: &str) -> Result<String>;

        #[cxx_name = "triggerSignal"]
        fn craby_test_trigger_signal(it_: &mut CrabyTest) -> Result<()>;

        #[cxx_name = "writeData"]
        fn craby_test_write_data(it_: &mut CrabyTest, value: &str) -> Result<bool>;
    }

    extern "Rust" {
        type CrabyTestSignal;
        fn get_on_error_payload(s: &CrabyTestSignal) -> MyModuleError;
        fn get_on_progress_payload(s: &CrabyTestSignal) -> ProgressEvent;
        unsafe fn drop_signal(signal: *mut CrabyTestSignal);
    }

    #[namespace = "craby::crabytest::signals"]
    unsafe extern "C++" {
        include!("CrabySignals.h");

        type SignalManager;

        unsafe fn emit(self: &SignalManager, id: usize, name: &str, signal: *mut CrabyTestSignal);
    
        #[rust_name = "get_signal_manager"]
        fn getSignalManager() -> &'static SignalManager;
    }
}

fn create_calculator(id: usize, data_path: &str) -> Box<Calculator> {
    let ctx = Context::new(id, data_path);
    Box::new(Calculator::new(ctx))
}

fn calculator_add(it_: &mut Calculator, a: f64, b: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.add(a, b);
        ret
    })
}

fn calculator_divide(it_: &mut Calculator, a: f64, b: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.divide(a, b);
        ret
    })
}

fn calculator_multiply(it_: &mut Calculator, a: f64, b: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.multiply(a, b);
        ret
    })
}

fn calculator_subtract(it_: &mut Calculator, a: f64, b: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.subtract(a, b);
        ret
    })
}

fn create_craby_test(id: usize, data_path: &str) -> Box<CrabyTest> {
    let ctx = Context::new(id, data_path);
    Box::new(CrabyTest::new(ctx))
}

fn craby_test_array_method(it_: &mut CrabyTest, arg: Vec<f64>) -> Result<Vec<f64>, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.array_method(arg);
        ret
    })
}

fn craby_test_boolean_method(it_: &mut CrabyTest, arg: bool) -> Result<bool, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.boolean_method(arg);
        ret
    })
}

fn craby_test_camel_method(it_: &mut CrabyTest) -> Result<(), anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.camel_method();
        ret
    })
}

fn craby_test_enum_method(it_: &mut CrabyTest, arg_0: MyEnum, arg_1: SwitchState) -> Result<String, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.enum_method(arg_0, arg_1);
        ret
    })
}

fn craby_test_get_data_path(it_: &mut CrabyTest) -> Result<String, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.get_data_path();
        ret
    })
}

fn craby_test_get_state(it_: &mut CrabyTest) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.get_state();
        ret
    })
}

fn craby_test_nullable_method(it_: &mut CrabyTest, arg: NullableNumber) -> Result<NullableNumber, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.nullable_method(arg.into());
        ret.into()
    })
}

fn craby_test_numeric_method(it_: &mut CrabyTest, arg: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.numeric_method(arg);
        ret
    })
}

fn craby_test_object_method(it_: &mut CrabyTest, arg: TestObject) -> Result<TestObject, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.object_method(arg);
        ret
    })
}

fn craby_test_pascal_method(it_: &mut CrabyTest) -> Result<(), anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.pascal_method();
        ret
    })
}

fn craby_test_promise_method(it_: &mut CrabyTest, arg: f64) -> Result<f64, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.promise_method(arg);
        ret
    }).and_then(|r| r)
}

fn craby_test_read_data(it_: &mut CrabyTest) -> Result<NullableString, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.read_data();
        ret.into()
    })
}

fn craby_test_set_state(it_: &mut CrabyTest, arg: f64) -> Result<(), anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.set_state(arg);
        ret
    })
}

fn craby_test_snake_method(it_: &mut CrabyTest) -> Result<(), anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.snake_method();
        ret
    })
}

fn craby_test_string_method(it_: &mut CrabyTest, arg: &str) -> Result<String, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.string_method(arg);
        ret
    })
}

fn craby_test_trigger_signal(it_: &mut CrabyTest) -> Result<(), anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.trigger_signal();
        ret
    }).and_then(|r| r)
}

fn craby_test_write_data(it_: &mut CrabyTest, value: &str) -> Result<bool, anyhow::Error> {
    craby::catch_panic!({
        let ret = it_.write_data(value);
        ret
    })
}

fn get_on_error_payload(s: &CrabyTestSignal) -> MyModuleError {
    match s {
        CrabyTestSignal::OnError(payload) => (*payload).clone(),
        _ => panic!("Invalid signal type for get_on_error_payload"),
    }
}

fn get_on_progress_payload(s: &CrabyTestSignal) -> ProgressEvent {
    match s {
        CrabyTestSignal::OnProgress(payload) => (*payload).clone(),
        _ => panic!("Invalid signal type for get_on_progress_payload"),
    }
}

unsafe fn drop_signal(signal: *mut CrabyTestSignal) {
    if !signal.is_null() {
        let _ = Box::from_raw(signal);
    }
}
