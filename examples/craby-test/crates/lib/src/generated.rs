// Auto generated by Craby. DO NOT EDIT.
#[rustfmt::skip]
use crate::ffi::bridging::*;
use crate::types::*;

pub trait CalculatorSpec {
    fn new(id: usize) -> Self;
    fn id(&self) -> usize;
    fn add(&mut self, a: Number, b: Number) -> Number;
    fn subtract(&mut self, a: Number, b: Number) -> Number;
    fn multiply(&mut self, a: Number, b: Number) -> Number;
    fn divide(&mut self, a: Number, b: Number) -> Number;
}

pub trait CrabyTestSpec {
    fn new(id: usize) -> Self;
    fn id(&self) -> usize;
    fn emit(&self, signal_name: CrabyTestSignal) {
        let manager = crate::ffi::bridging::get_signal_manager();
        match signal_name {
            CrabyTestSignal::OnSignal => manager.emit(self.id(), "onSignal"),
        }
    }
    fn numeric_method(&mut self, arg: Number) -> Number;
    fn boolean_method(&mut self, arg: Boolean) -> Boolean;
    fn string_method(&mut self, arg: String) -> String;
    fn object_method(&mut self, arg: TestObject) -> TestObject;
    fn array_method(&mut self, arg: Array<Number>) -> Array<Number>;
    fn enum_method(&mut self, arg_0: MyEnum, arg_1: SwitchState) -> String;
    fn nullable_method(&mut self, arg: Nullable<Number>) -> Nullable<Number>;
    fn promise_method(&mut self, arg: Number) -> Promise<Number>;
    fn set_state(&mut self, arg: Number) -> Void;
    fn get_state(&mut self) -> Number;
    fn camel_method(&mut self) -> Void;
    fn pascal_method(&mut self) -> Void;
    fn snake_method(&mut self) -> Void;
    fn trigger_signal(&mut self) -> Void;
}

pub enum CrabyTestSignal {
    OnSignal,
}

impl Default for MyEnum {
    fn default() -> Self {
        MyEnum::Foo
    }
}

impl Default for NullableString {
    fn default() -> Self {
        NullableString {
            null: true,
            val: String::default(),
        }
    }
}

impl From<NullableString> for Nullable<String> {
    fn from(val: NullableString) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<String>> for NullableString {
    fn from(val: Nullable<String>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableString {
            val: val.unwrap_or(String::default()),
            null,
        }
    }
}

impl Default for SubObject {
    fn default() -> Self {
        SubObject {
            a: NullableString::default(),
            b: 0.0,
            c: false
        }
    }
}

impl Default for SwitchState {
    fn default() -> Self {
        SwitchState::Off
    }
}

impl Default for NullableSubObject {
    fn default() -> Self {
        NullableSubObject {
            null: true,
            val: SubObject::default(),
        }
    }
}

impl From<NullableSubObject> for Nullable<SubObject> {
    fn from(val: NullableSubObject) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<SubObject>> for NullableSubObject {
    fn from(val: Nullable<SubObject>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableSubObject {
            val: val.unwrap_or(SubObject::default()),
            null,
        }
    }
}

impl Default for TestObject {
    fn default() -> Self {
        TestObject {
            foo: String::default(),
            bar: 0.0,
            baz: false,
            sub: NullableSubObject::default(),
            camel_case: 0.0,
            pascal_case: 0.0,
            snake_case: 0.0
        }
    }
}

impl Default for NullableNumber {
    fn default() -> Self {
        NullableNumber {
            null: true,
            val: 0.0,
        }
    }
}

impl From<NullableNumber> for Nullable<Number> {
    fn from(val: NullableNumber) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<Number>> for NullableNumber {
    fn from(val: Nullable<Number>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableNumber {
            val: val.unwrap_or(0.0),
            null,
        }
    }
}
