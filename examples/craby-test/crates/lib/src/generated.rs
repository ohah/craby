// Auto generated by Craby. DO NOT EDIT.
// Hash: 8742d8c38b968c19
#[rustfmt::skip]
use craby::prelude::*;

use crate::ffi::bridging::*;

pub trait CalculatorSpec {
    fn new(ctx: Context) -> Self;
    fn id(&self) -> usize;
    fn add(&mut self, a: Number, b: Number) -> Number;
    fn divide(&mut self, a: Number, b: Number) -> Number;
    fn multiply(&mut self, a: Number, b: Number) -> Number;
    fn subtract(&mut self, a: Number, b: Number) -> Number;
}

pub trait CrabyTestSpec {
    fn new(ctx: Context) -> Self;
    fn id(&self) -> usize;
    fn emit(&self, signal_name: CrabyTestSignal) {
        let manager = crate::ffi::bridging::get_signal_manager();
        match signal_name {
            CrabyTestSignal::OnError(data) => {
                let signal = Box::new(CrabyTestSignal::OnError(data));
                let signal_ptr = Box::into_raw(signal);
                unsafe {
                    manager.emit(self.id(), "onError", signal_ptr);
                }
            }
            CrabyTestSignal::OnProgress(data) => {
                let signal = Box::new(CrabyTestSignal::OnProgress(data));
                let signal_ptr = Box::into_raw(signal);
                unsafe {
                    manager.emit(self.id(), "onProgress", signal_ptr);
                }
            }
            CrabyTestSignal::OnSignal => {
                unsafe {
                    manager.emit(self.id(), "onSignal", std::ptr::null_mut());
                }
            }
        }
    }
    fn array_buffer_method(&mut self, arg: Vec<u8>) -> Vec<u8>; // TODO: update codegen
    fn array_method(&mut self, arg: Array<Number>) -> Array<Number>;
    fn boolean_method(&mut self, arg: Boolean) -> Boolean;
    fn camel_method(&mut self) -> Void;
    fn enum_method(&mut self, arg_0: MyEnum, arg_1: SwitchState) -> String;
    fn get_data_path(&mut self) -> String;
    fn get_state(&mut self) -> Number;
    fn nullable_method(&mut self, arg: Nullable<Number>) -> Nullable<Number>;
    fn numeric_method(&mut self, arg: Number) -> Number;
    fn object_method(&mut self, arg: TestObject) -> TestObject;
    fn pascal_method(&mut self) -> Void;
    fn promise_method(&mut self, arg: Number) -> Promise<Number>;
    fn read_data(&mut self) -> Nullable<String>;
    fn set_state(&mut self, arg: Number) -> Void;
    fn snake_method(&mut self) -> Void;
    fn string_method(&mut self, arg: &str) -> String;
    fn trigger_signal(&mut self) -> Promise<Void>;
    fn write_data(&mut self, value: &str) -> Boolean;
}

pub enum CrabyTestSignal {
    OnError(MyModuleError),
    OnProgress(ProgressEvent),
    OnSignal,
}

impl Default for ProgressEvent {
    fn default() -> Self {
        ProgressEvent {
            progress: 0.0
        }
    }
}

impl Default for NullableSubObject {
    fn default() -> Self {
        NullableSubObject {
            null: true,
            val: SubObject::default(),
        }
    }
}

impl From<NullableSubObject> for Nullable<SubObject> {
    fn from(val: NullableSubObject) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<SubObject>> for NullableSubObject {
    fn from(val: Nullable<SubObject>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableSubObject {
            val: val.unwrap_or(SubObject::default()),
            null,
        }
    }
}

impl Default for SwitchState {
    fn default() -> Self {
        SwitchState::Off
    }
}

impl Default for NullableString {
    fn default() -> Self {
        NullableString {
            null: true,
            val: String::default(),
        }
    }
}

impl From<NullableString> for Nullable<String> {
    fn from(val: NullableString) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<String>> for NullableString {
    fn from(val: Nullable<String>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableString {
            val: val.unwrap_or(String::default()),
            null,
        }
    }
}

impl Default for NullableNumber {
    fn default() -> Self {
        NullableNumber {
            null: true,
            val: 0.0,
        }
    }
}

impl From<NullableNumber> for Nullable<Number> {
    fn from(val: NullableNumber) -> Self {
        Nullable::new(if val.null { None } else { Some(val.val) })
    }
}

impl From<Nullable<Number>> for NullableNumber {
    fn from(val: Nullable<Number>) -> Self {
        let val = val.into_value();
        let null = val.is_none();
        NullableNumber {
            val: val.unwrap_or(0.0),
            null,
        }
    }
}

impl Default for TestObject {
    fn default() -> Self {
        TestObject {
            foo: String::default(),
            bar: 0.0,
            baz: false,
            sub: NullableSubObject::default(),
            camel_case: 0.0,
            pascal_case: 0.0,
            snake_case: 0.0
        }
    }
}

impl Default for MyModuleError {
    fn default() -> Self {
        MyModuleError {
            reason: String::default()
        }
    }
}

impl Default for MyEnum {
    fn default() -> Self {
        MyEnum::Foo
    }
}

impl Default for SubObject {
    fn default() -> Self {
        SubObject {
            a: NullableString::default(),
            b: 0.0,
            c: false
        }
    }
}
